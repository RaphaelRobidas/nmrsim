

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nmrsim package &mdash; nmrsim 0.2.2-alpha documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> nmrsim
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction to nmrsim v0.2.2 (beta)</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to <strong>nmrsim</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">nmrsim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>nmrsim package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/nmrsim.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="nmrsim-package">
<h1>nmrsim package<a class="headerlink" href="#nmrsim-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nmrsim.discrete">
<span id="nmrsim-discrete-module"></span><h2>nmrsim.discrete module<a class="headerlink" href="#module-nmrsim.discrete" title="Permalink to this headline">¶</a></h2>
<p>Non-quantum mechanical solutions for specific second-order patterns.</p>
<p>These are adapted from the routines from WINDNMR <a class="footnote-reference brackets" href="#id3" id="id1">1</a> by Hans Reich,
U. Wisconsin, and equations from Pople, Schneider and Bernstein <a class="footnote-reference brackets" href="#id4" id="id2">2</a>. Note that
many of the names for arguments, etc. are non-Pythonic but chosen to match the
WINDNMR interface and source code (for now).</p>
<p>The <cite>partials</cite> module provides the following functions:</p>
<ul class="simple">
<li><p>AB: simulates an AB quartet.</p></li>
<li><p>AB2: simulates an AB2 system.</p></li>
<li><p>ABX: simulates an ABX system.</p></li>
</ul>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>WINDNMR-Pro home page: <a class="reference external" href="https://www.chem.wisc.edu/areas/reich/plt/windnmr.htm">https://www.chem.wisc.edu/areas/reich/plt/windnmr.htm</a></p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Pople, J.A.; Schneider, W.G.; Bernstein, H.J. <em>High-Resolution Nuclear Magnetic Resonance.</em> New York:
McGraw-Hill, 1959.</p>
</dd>
</dl>
<dl class="function">
<dt id="nmrsim.discrete.AABB">
<code class="sig-prename descclassname">nmrsim.discrete.</code><code class="sig-name descname">AABB</code><span class="sig-paren">(</span><em class="sig-param">Vab</em>, <em class="sig-param">Jaa</em>, <em class="sig-param">Jbb</em>, <em class="sig-param">Jab</em>, <em class="sig-param">Jab_prime</em>, <em class="sig-param">Vcentr</em>, <em class="sig-param">normalize=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/discrete.html#AABB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.discrete.AABB" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for a second-order AA’BB’ calculation, but using the
same arguments as WINDNMR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Vab</strong> (<em>float</em>) – the difference in frequency (Hz) between Ha and Hb in the absence of
coupling. A positive number indicates vb &gt; va.</p></li>
<li><p><strong>Jbb</strong><strong>, </strong><strong>Jab</strong><strong>, </strong><strong>Jab_prime</strong> (<em>Jaa</em><em>,</em>) – Jaa is the JAA’ coupling constant;
Jxx the JXX’;
Jax the JAX; and
JAX_prime the JAX’.</p></li>
<li><p><strong>Vcentr</strong> (<em>float</em>) – the frequency for the center of the signal.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – whether the signal intensity should be normalized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of (frequency, intensity) tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.discrete.AAXX">
<code class="sig-prename descclassname">nmrsim.discrete.</code><code class="sig-name descname">AAXX</code><span class="sig-paren">(</span><em class="sig-param">Jaa</em>, <em class="sig-param">Jxx</em>, <em class="sig-param">Jax</em>, <em class="sig-param">Jax_prime</em>, <em class="sig-param">Vcentr</em>, <em class="sig-param">normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/discrete.html#AAXX"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.discrete.AAXX" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulates one half (‘A’ part) of an AA’XX’ spin system.</p>
<p>All frequencies are in Hz.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Jax</strong><strong>, </strong><strong>Jax</strong><strong>, </strong><strong>Jax_prime</strong> (<em>Jaa</em><em>,</em>) – Jaa is the JAA’ coupling constant;
Jxx the JXX’;
Jax the JAX; and
JAX_prime the JAX’.</p></li>
<li><p><strong>Vcentr</strong> (<em>float</em>) – the frequency for the center of the signal.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – whether the signal intensity should be normalized (to 2).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of (frequency, intensity) tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.discrete.AB">
<code class="sig-prename descclassname">nmrsim.discrete.</code><code class="sig-name descname">AB</code><span class="sig-paren">(</span><em class="sig-param">Jab</em>, <em class="sig-param">Vab</em>, <em class="sig-param">Vcentr</em>, <em class="sig-param">normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/discrete.html#AB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.discrete.AB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the signal frequencies and intensities for two strongly
coupled protons (Ha and Hb).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Jab</strong> (<em>float</em>) – The coupling constant (Hz) between Ha and Hb</p></li>
<li><p><strong>Vab</strong> (<em>float</em>) – The chemical shift difference (Hz) between Ha and Hb in the absence
of coupling.</p></li>
<li><p><strong>Vcentr</strong> (<em>float</em>) – The frequency (Hz) for the center of the AB quartet.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – Whether the signal intensity should be normalized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of four (frequency, intensity) tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.discrete.AB2">
<code class="sig-prename descclassname">nmrsim.discrete.</code><code class="sig-name descname">AB2</code><span class="sig-paren">(</span><em class="sig-param">Jab</em>, <em class="sig-param">Vab</em>, <em class="sig-param">Vcentr</em>, <em class="sig-param">normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/discrete.html#AB2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.discrete.AB2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates signal frequencies and intensities for an AB2 spin system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Jab</strong> (<em>float</em>) – the Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Vab</strong> (<em>float</em>) – the difference in the frequencies (Hz). A positive value means vb &gt; va;
negative means va &gt; vb.</p></li>
<li><p><strong>Vcentr</strong> (<em>float</em>) – the frequency (Hz) for the center of the AB2 signal.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – whether the signal intensity should be normalized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of (frequency, intensity) tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.discrete.ABX">
<code class="sig-prename descclassname">nmrsim.discrete.</code><code class="sig-name descname">ABX</code><span class="sig-paren">(</span><em class="sig-param">Jab</em>, <em class="sig-param">Jax</em>, <em class="sig-param">Jbx</em>, <em class="sig-param">Vab</em>, <em class="sig-param">Vcentr</em>, <em class="sig-param">vx</em>, <em class="sig-param">normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/discrete.html#ABX"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.discrete.ABX" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-QM approximation for an ABX spin system. The approximation assumes
that Hx is very far away in chemical shift from Ha/Hb.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Jab</strong> (<em>float</em>) – The Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Jbx</strong> (<em>float</em>) – The Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Jax</strong> (<em>float</em>) – The Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Vab</strong> (<em>float</em>) – The difference in the frequencies (in the absence of
coupling) of Ha and Hb (Hz).</p></li>
<li><p><strong>Vcentr</strong> (<em>float</em>) – The frequency (Hz) for the center of the AB signal.</p></li>
<li><p><strong>vx</strong> (<em>float</em>) – The frequency (Hz) for Hx in the absence of coupling.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – whether the signal intensity should be normalized. If false, the total
signal intensity happens to be ~12.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of (frequency, intensity) tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.discrete.ABX3">
<code class="sig-prename descclassname">nmrsim.discrete.</code><code class="sig-name descname">ABX3</code><span class="sig-paren">(</span><em class="sig-param">Jab</em>, <em class="sig-param">Jax</em>, <em class="sig-param">Jbx</em>, <em class="sig-param">Vab</em>, <em class="sig-param">Vcentr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/discrete.html#ABX3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.discrete.ABX3" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulation of the AB part of an ABX3 spin system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Jab</strong> (<em>float</em>) – the Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Jax</strong> (<em>float</em>) – the Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Jbx</strong> (<em>float</em>) – the Ha-Hb coupling constant (Hz).</p></li>
<li><p><strong>Vab</strong> (<em>float</em>) – the difference in the frequencies (Hz) of Ha and Hb in the absence of
coupling. Positive when vb &gt; va.</p></li>
<li><p><strong>Vcentr</strong> (<em>float</em>) – the frequency (Hz) for the center of the AB signal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of (frequency, intensity) tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nmrsim.dnmr">
<span id="nmrsim-dnmr-module"></span><h2>nmrsim.dnmr module<a class="headerlink" href="#module-nmrsim.dnmr" title="Permalink to this headline">¶</a></h2>
<p>The <cite>dnmr</cite> module provides functions for calculating DNMR line shapes, and
classes to describe DNMR systems.</p>
<p>The dnmr module provides the following classes:</p>
<ul class="simple">
<li><p><cite>DnmrTwoSinglets</cite>: a sumulation of the lineshape for two uncoupled nuclei
undergoing exchange.</p></li>
<li><p><cite>DnmrAB</cite>: a simulation of the lineshape for two coupled nuclei undergoing
exchange (i.e. an AB (or AX) pattern at the slow exchange limit).</p></li>
</ul>
<p>The <cite>dnmr</cite> module provides the following functions:</p>
<ul class="simple">
<li><p><cite>dnmr_two_singlets</cite>: for simulating the lineshape for two uncoupled nuclei
undergoing exchange <a class="footnote-reference brackets" href="#id7" id="id5">3</a>.</p></li>
<li><p><cite>dnmr_AB</cite> : for simulating the lineshape for two coupled nuclei undergoing
exchange (i.e. an AB (or AX) pattern at the slow exchange limit) <a class="footnote-reference brackets" href="#id8" id="id6">4</a>.</p></li>
</ul>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>Sandström, J. Dynamic NMR Spectroscopy; Academic Press: New York, 1982.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><ol class="loweralpha simple">
<li><p>Brown, K.C.; Tyson, R.L.; Weil, J.A. J. Chem. Educ. 1998, 75, 1632.</p></li>
<li><p>an important math correction to the previous reference:</p></li>
</ol>
<blockquote>
<div><p>TODO: add reference to correction</p>
</div></blockquote>
</dd>
</dl>
<dl class="class">
<dt id="nmrsim.dnmr.DnmrAB">
<em class="property">class </em><code class="sig-prename descclassname">nmrsim.dnmr.</code><code class="sig-name descname">DnmrAB</code><span class="sig-paren">(</span><em class="sig-param">va=165.0</em>, <em class="sig-param">vb=135.0</em>, <em class="sig-param">J=12.0</em>, <em class="sig-param">k=12.0</em>, <em class="sig-param">w=0.5</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">points=800</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#DnmrAB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.dnmr.DnmrAB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simulate the DNMR lineshape for two coupled nuclei undergoing exchange
(AB or AX pattern at the slow-exchange limit).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vb</strong> (<em>va</em><em>,</em>) – frequencies of a and b nuclei (at the slow exchange limit,
in the absence of coupling)</p></li>
<li><p><strong>J</strong> (<em>int</em><em> or </em><em>float</em>) – the coupling constant between the two nuclei.</p></li>
<li><p><strong>k</strong> (<em>int</em><em> or </em><em>float</em>) – rate constant for state A–&gt; state B</p></li>
<li><p><strong>w</strong> (<em>int</em><em> or </em><em>float</em>) – peak widths at half height (at the slow-exchange limit).</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>int</em><em> or </em><em>float</em><em>, </em><em>int</em><em> or </em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The minimum and maximum frequencies (in any order) for the simulation.</p></li>
<li><p><strong>points</strong> (<em>int</em>) – The length of the returned arrays (i.e. the number of points plotted).</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.va">
<code class="sig-name descname">va</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.va" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.vb">
<code class="sig-name descname">vb</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.vb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.J">
<code class="sig-name descname">J</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.J" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.k">
<code class="sig-name descname">k</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.k" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.w">
<code class="sig-name descname">w</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.w" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.limits">
<code class="sig-name descname">limits</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrAB.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmrsim.dnmr.DnmrAB.lineshape">
<code class="sig-name descname">lineshape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#DnmrAB.lineshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.dnmr.DnmrAB.lineshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the x, y (frequency, intensity) data for the lineshape
simulation.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nmrsim.dnmr.DnmrAB" title="nmrsim.dnmr.DnmrAB"><code class="xref py py-class docutils literal notranslate"><span class="pre">DnmrAB</span></code></a></dt><dd><p>A class representation for this simulation.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See the documentation for the nmrsim.dnmr module.</p>
<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">J</code></dt>
<dd><p>The coupling constant (Hz) between the two nuclei.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">k</code></dt>
<dd><p>The rate constant (Hz) for state A–&gt; state B (must be &gt;0).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">limits</code></dt>
<dd><p>The minimum and maximum frequencies for the simulated lineshape.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(int or float, int or float)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">lineshape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#DnmrAB.lineshape"><span class="viewcode-link">[source]</span></a></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">points</code></dt>
<dd><p>The length of the returned arrays (i.e. the number of points plotted).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">va</code></dt>
<dd><p>The frequency of nucleus “a” (Hz) at the slow-exchange limit, in the
absence of coupling.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">vb</code></dt>
<dd><p>The frequency of nucleus “b” (Hz) at the slow-exchange limit, in the
absence of coupling.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">w</code></dt>
<dd><p>The peak width (Hz) at half height (at the slow-exchange limit).
:returns:
:rtype: int or float</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmrsim.dnmr.DnmrTwoSinglets">
<em class="property">class </em><code class="sig-prename descclassname">nmrsim.dnmr.</code><code class="sig-name descname">DnmrTwoSinglets</code><span class="sig-paren">(</span><em class="sig-param">va=1</em>, <em class="sig-param">vb=0</em>, <em class="sig-param">k=0.01</em>, <em class="sig-param">wa=0.5</em>, <em class="sig-param">wb=0.5</em>, <em class="sig-param">pa=0.5</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">points=800</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#DnmrTwoSinglets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A DNMR simulation for two uncoupled nuclei undergoing exchange.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vb</strong> (<em>va</em><em>,</em>) – The frequencies (Hz) of nuclei ‘a’ and ‘b’ at the slow exchange limit.</p></li>
<li><p><strong>k</strong> (<em>int</em><em> or </em><em>float</em>) – The rate constant (Hz) for state a–&gt; state b</p></li>
<li><p><strong>wb</strong> (<em>wa</em><em>,</em>) – The peak widths at half height for the ‘a’ and ‘b’ singlets at the
slow-exchange limit.</p></li>
<li><p><strong>pa</strong> (<em>float</em><em> (</em><em>0 &lt;= pa &lt;= 1</em><em>)</em>) – The fraction of the population in state a</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>int</em><em> or </em><em>float</em><em>, </em><em>int</em><em> or </em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The minimum and maximum frequencies (in any order) for the simulation.</p></li>
<li><p><strong>points</strong> (<em>int</em>) – The length of the returned arrays (i.e. the number of points plotted).</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.va">
<code class="sig-name descname">va</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.va" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.vb">
<code class="sig-name descname">vb</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.vb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.k">
<code class="sig-name descname">k</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.k" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.wa">
<code class="sig-name descname">wa</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.wa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.wb">
<code class="sig-name descname">wb</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.wb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.pa">
<code class="sig-name descname">pa</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.pa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.limits">
<code class="sig-name descname">limits</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmrsim.dnmr.DnmrTwoSinglets.lineshape">
<code class="sig-name descname">lineshape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#DnmrTwoSinglets.lineshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.dnmr.DnmrTwoSinglets.lineshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the x, y (frequency, intensity) data for the lineshape
simulation.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nmrsim.dnmr.DnmrTwoSinglets" title="nmrsim.dnmr.DnmrTwoSinglets"><code class="xref py py-class docutils literal notranslate"><span class="pre">DnmrTwoSinglets</span></code></a></dt><dd><p>A class representation for this simulation</p>
</dd>
</dl>
</div>
<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">k</code></dt>
<dd><p>The rate constant (Hz) for state A–&gt; state B (must be &gt;0).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">limits</code></dt>
<dd><p>The minimum and maximum frequencies for the simulated lineshape.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(int or float, int or float)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">lineshape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#DnmrTwoSinglets.lineshape"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Calculate and return the lineshape for the DNMR spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>x, y</strong> – Arrays for the x (frequency) and y (intensity) lineshape data
points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.array, numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">pa</code></dt>
<dd><p>float
The fraction of the population in state a. Must be &gt;=0 and &lt;=1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">points</code></dt>
<dd><p>The length of the returned arrays (i.e. the number of points plotted).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">va</code></dt>
<dd><p>The frequency of nucleus “a” (Hz) at the slow-exchange limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">vb</code></dt>
<dd><p>The frequency of nucleus “b” (Hz) at the slow-exchange limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">wa</code></dt>
<dd><p>The peak width at half height (Hz) for the ‘a’ singlet at the
slow-exchange limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">wb</code></dt>
<dd><p>The peak width at half height (Hz) for the ‘b’ singlet at the
slow-exchange limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nmrsim.dnmr.dnmr_AB">
<code class="sig-prename descclassname">nmrsim.dnmr.</code><code class="sig-name descname">dnmr_AB</code><span class="sig-paren">(</span><em class="sig-param">va</em>, <em class="sig-param">vb</em>, <em class="sig-param">J</em>, <em class="sig-param">k</em>, <em class="sig-param">w</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">points=800</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#dnmr_AB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.dnmr.dnmr_AB" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the DNMR lineshape for two coupled nuclei undergoing exchange
(AB or AX pattern at the slow-exchange limit).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vb</strong> (<em>va</em><em>,</em>) – frequencies of a and b nuclei (at the slow exchange limit,
in the absence of coupling)</p></li>
<li><p><strong>J</strong> (<em>float</em>) – the coupling constant between the two nuclei.</p></li>
<li><p><strong>k</strong> (<em>float</em>) – rate constant for state A–&gt; state B</p></li>
<li><p><strong>w</strong> (<em>float</em>) – peak widths at half height (at the slow-exchange limit).</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>int</em><em> or </em><em>float</em><em>, </em><em>int</em><em> or </em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The minimum and maximum frequencies (in any order) for the simulation.</p></li>
<li><p><strong>points</strong> (<em>int</em>) – The length of the returned arrays (i.e. the number of points plotted).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x, y</strong> – Arrays for the x (frequency) and y (intensity) lineshape data points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, numpy.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nmrsim.dnmr.DnmrAB" title="nmrsim.dnmr.DnmrAB"><code class="xref py py-func docutils literal notranslate"><span class="pre">DnmrAB()</span></code></a></dt><dd><p>A class representation for this simulation.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See the documentation for the nmrsim.dnmr module.</p>
</dd></dl>

<dl class="function">
<dt id="nmrsim.dnmr.dnmr_two_singlets">
<code class="sig-prename descclassname">nmrsim.dnmr.</code><code class="sig-name descname">dnmr_two_singlets</code><span class="sig-paren">(</span><em class="sig-param">va</em>, <em class="sig-param">vb</em>, <em class="sig-param">ka</em>, <em class="sig-param">wa</em>, <em class="sig-param">wb</em>, <em class="sig-param">pa</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">points=800</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/dnmr.html#dnmr_two_singlets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.dnmr.dnmr_two_singlets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a the lineshape for a DNMR spectrum of two uncoupled spin-half
nuclei.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vb</strong> (<em>va</em><em>,</em>) – The frequencies (Hz) of nuclei ‘a’ and ‘b’ at the slow exchange limit.</p></li>
<li><p><strong>ka</strong> (<em>int</em><em> or </em><em>float</em>) – The rate constant (Hz) for state a–&gt; state b</p></li>
<li><p><strong>wb</strong> (<em>wa</em><em>,</em>) – The peak widths at half height for the ‘a’ and ‘b’ singlets at the
slow-exchange limit.</p></li>
<li><p><strong>pa</strong> (<em>float</em><em> (</em><em>0 &lt;= pa &lt;= 1</em><em>)</em>) – The fraction of the population in state a</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>int</em><em> or </em><em>float</em><em>, </em><em>int</em><em> or </em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The minimum and maximum frequencies (in any order) for the simulation.</p></li>
<li><p><strong>points</strong> (<em>int</em>) – The length of the returned arrays (i.e. the number of points plotted).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x, y</strong> – Arrays for the x (frequency) and y (intensity) lineshape data points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, numpy.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nmrsim.dnmr.DnmrTwoSinglets" title="nmrsim.dnmr.DnmrTwoSinglets"><code class="xref py py-func docutils literal notranslate"><span class="pre">DnmrTwoSinglets()</span></code></a></dt><dd><p>A class representation for this simulation.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See the documentation for the nmrsim.dnmr module.</p>
</dd></dl>

</div>
<div class="section" id="module-nmrsim.firstorder">
<span id="nmrsim-firstorder-module"></span><h2>nmrsim.firstorder module<a class="headerlink" href="#module-nmrsim.firstorder" title="Permalink to this headline">¶</a></h2>
<p>“Functions for calculating first-order spectra.</p>
<p>The nmrsim.firstorder module provides the following functions:</p>
<ul class="simple">
<li><p>multiplet: performs first-order splitting of a signal into multiple signals.</p></li>
<li><dl class="simple">
<dt>first_order_spin_system: provides a peaklist for several nuclei, using the</dt><dd><p>same v/J parameters that are used for second-order spin systems.
See nmrsim.qm for details on these parameters.</p>
</dd>
</dl>
</li>
</ul>
<dl class="function">
<dt id="nmrsim.firstorder.first_order_spin_system">
<code class="sig-prename descclassname">nmrsim.firstorder.</code><code class="sig-name descname">first_order_spin_system</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">J</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/firstorder.html#first_order_spin_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.firstorder.first_order_spin_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a first-order peaklist of several multiplets from the same v/J
arguments used for qm calculations.</p>
<p>This allows a user to model several multiplets at once, rather than
creating each multiplet individually. It also provides a “toggle” where
the user, or a higher-level function/class (such as nmrsim.SpinSystem)
can decide whether a spin system is modeled as first order or second order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>array-like</em><em> [</em><em>float...</em><em>]</em>) – an array of frequencies</p></li>
<li><p><strong>J</strong> (<em>2D array-like</em><em> (</em><em>square</em><em>)</em>) – a matrix of J coupling constants</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a combined peaklist of signals for all the multiplets in the spin
system.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.firstorder.multiplet">
<code class="sig-prename descclassname">nmrsim.firstorder.</code><code class="sig-name descname">multiplet</code><span class="sig-paren">(</span><em class="sig-param">signal</em>, <em class="sig-param">couplings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/firstorder.html#multiplet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.firstorder.multiplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a set of signals into first-order multiplets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – a (frequency (Hz), intensity) tuple;</p></li>
<li><p><strong>couplings</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>int</em><em>)</em><em>..</em><em>]</em>) – A list of (<em>J</em>, # of nuclei) tuples. The order of the tuples in
couplings does not matter.
e.g. to split a signal into a <em>dt, J</em> = 8, 5 Hz, use:
<code class="docutils literal notranslate"><span class="pre">couplings</span> <span class="pre">=</span> <span class="pre">[(8,</span> <span class="pre">2),</span> <span class="pre">(5,</span> <span class="pre">3)]</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a sorted peaklist for the multiplet that results from splitting the
signal by each J.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nmrsim.math">
<span id="nmrsim-math-module"></span><h2>nmrsim.math module<a class="headerlink" href="#module-nmrsim.math" title="Permalink to this headline">¶</a></h2>
<p>A collection of functions for processing simulated NMR spectra.</p>
<p>Terms used:
signal: a pair (e.g. tuple) of frequency, intensity values
peaklist: a list (or 1D-array-like) of signals.</p>
<p>Provides the following functions:</p>
<ul class="simple">
<li><p>add_peaks: combines a list of signals into one signal of average frequency
and summed intensity.</p></li>
<li><p>reduce_peaks: processes a peaklist so that signals within a frequency
tolerance are added together.</p></li>
<li><p>normalize_peaklist: scales a peaklist so that intensities add to a specific
value.</p></li>
<li><p>lorentz: given a frequency, a signal and a linewidth, calculates an
intensity. Used to calculate Lorentzian lineshapes for signals.</p></li>
<li><p>get_intensity: given a lineshape and a frequency, find the intensity at the
datapoint closest to that frequency.</p></li>
</ul>
<dl class="function">
<dt id="nmrsim.math.add_peaks">
<code class="sig-prename descclassname">nmrsim.math.</code><code class="sig-name descname">add_peaks</code><span class="sig-paren">(</span><em class="sig-param">plist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/math.html#add_peaks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.math.add_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces a list of (frequency, intensity) tuples to an
(average frequency, total intensity) tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>plist</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>..</em><em>]</em>) – a list of (frequency, intensity) tuples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of (average frequency, total intensity)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(float, float)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.math.get_intensity">
<code class="sig-prename descclassname">nmrsim.math.</code><code class="sig-name descname">get_intensity</code><span class="sig-paren">(</span><em class="sig-param">lineshape</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/math.html#get_intensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.math.get_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>A crude method to find the intensity of data point closest to
frequency x. Better: interpolate between two data points if match isn’t
exact (TODO?)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lineshape</strong> (<em>tuple of</em><em> (</em><em>x</em><em>, </em><em>y</em><em>) </em><em>arrays for frequency</em><em>, </em><em>intensity data</em>) – </p></li>
<li><p><strong>x</strong> (<em>frequency lookup</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>float</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>the intensity at that frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.math.get_maxima">
<code class="sig-prename descclassname">nmrsim.math.</code><code class="sig-name descname">get_maxima</code><span class="sig-paren">(</span><em class="sig-param">lineshape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/math.html#get_maxima"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.math.get_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Crude function that returns maxima in the lineshape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lineshape</strong> (<em>tuple of frequency</em><em>, </em><em>intensity arrays</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a list of (frequency, intensity) tuples for individual maxima.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.math.lorentz">
<code class="sig-prename descclassname">nmrsim.math.</code><code class="sig-name descname">lorentz</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">v0</em>, <em class="sig-param">I</em>, <em class="sig-param">w</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/math.html#lorentz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.math.lorentz" title="Permalink to this definition">¶</a></dt>
<dd><p>A lorentz function that takes linewidth at half intensity (w) as a
parameter.</p>
<p>When <cite>v</cite> = <cite>v0</cite>, and <cite>w</cite> = 0.5 (Hz), the function returns intensity I.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>float</em>) – The frequency (x coordinate) in Hz at which to evaluate intensity (y
coordinate).</p></li>
<li><p><strong>v0</strong> (<em>float</em>) – The center of the distribution.</p></li>
<li><p><strong>I</strong> (<em>float</em>) – the relative intensity of the signal</p></li>
<li><p><strong>w</strong> (<em>float</em>) – the peak width at half maximum intensity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the intensity (y coordinate) for the Lorentzian distribution
evaluated at frequency <cite>v</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.math.normalize_peaklist">
<code class="sig-prename descclassname">nmrsim.math.</code><code class="sig-name descname">normalize_peaklist</code><span class="sig-paren">(</span><em class="sig-param">peaklist</em>, <em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/math.html#normalize_peaklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.math.normalize_peaklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the intensities in a peaklist so that total intensity equals
value n (nominally the number of nuclei giving rise to the signal).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peaklist</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>..</em><em>]</em>) – a list of (frequency, intensity) tuples.</p></li>
<li><p><strong>n</strong> (<em>int</em><em> or </em><em>float</em><em> (</em><em>optional</em><em>)</em>) – total intensity to normalize to (default = 1).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.math.reduce_peaks">
<code class="sig-prename descclassname">nmrsim.math.</code><code class="sig-name descname">reduce_peaks</code><span class="sig-paren">(</span><em class="sig-param">plist_</em>, <em class="sig-param">tolerance=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/math.html#reduce_peaks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.math.reduce_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of (x, y) tuples and adds together tuples whose values are
within a certain tolerance limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plist</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>..</em><em>]</em>) – A list of (x, y) tuples</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – tuples that differ in x by &lt;= tolerance are combined using <cite>add_peaks</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of (x, y) tuples where all x values differ by &gt; <cite>tolerance</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nmrsim.plt">
<span id="nmrsim-plt-module"></span><h2>nmrsim.plt module<a class="headerlink" href="#module-nmrsim.plt" title="Permalink to this headline">¶</a></h2>
<p>The plt module provides convenience functions for creating matplotlib plots,
plus applying Lorentzian distributions about signals.</p>
<p>The plt module provides the following functions:</p>
<ul class="simple">
<li><p>add_lorentzians: Creates lineshape data from a provided linspace (array of x
coordinates) and peaklist).</p></li>
<li><p>mplplot: Creates a lineshape plot from a peaklist and returns the x, y plot
data.</p></li>
<li><p>mplplot_stick: Creates a “stick” (matplotlib “stem” plot) plot from a
peaklist and returns the x, y plot data.</p></li>
<li><p>mplplot_lineshape: Creates a lineshape plot from provided x, y lineshape data
and returns the x, y plot data.</p></li>
</ul>
<dl class="function">
<dt id="nmrsim.plt.add_lorentzians">
<code class="sig-prename descclassname">nmrsim.plt.</code><code class="sig-name descname">add_lorentzians</code><span class="sig-paren">(</span><em class="sig-param">linspace</em>, <em class="sig-param">peaklist</em>, <em class="sig-param">w</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/plt.html#add_lorentzians"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.plt.add_lorentzians" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a numpy linspace, a peaklist of (frequency, intensity)
tuples, and a linewidth, returns an array of y coordinates for the
total line shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linspace</strong> (<em>array-like</em>) – Normally a numpy.linspace of x coordinates corresponding to frequency
in Hz.</p></li>
<li><p><strong>peaklist</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>..</em><em>]</em>) – A list of (frequency, intensity) tuples.</p></li>
<li><p><strong>w</strong> (<em>float</em>) – Peak width at half maximum intensity.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an array of y coordinates corresponding to intensity.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[float…]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.plt.mplplot">
<code class="sig-prename descclassname">nmrsim.plt.</code><code class="sig-name descname">mplplot</code><span class="sig-paren">(</span><em class="sig-param">peaklist</em>, <em class="sig-param">w=1</em>, <em class="sig-param">y_min=-0.01</em>, <em class="sig-param">y_max=1</em>, <em class="sig-param">points=800</em>, <em class="sig-param">limits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/plt.html#mplplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.plt.mplplot" title="Permalink to this definition">¶</a></dt>
<dd><p>A matplotlib plot of the simulated lineshape for a peaklist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peaklist</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>..</em><em>]</em>) – A list of (frequency, intensity) tuples.</p></li>
<li><p><strong>w</strong> (<em>float</em>) – Peak width at half height</p></li>
<li><p><strong>y_min</strong> (<em>float</em><em> or </em><em>int</em>) – Minimum intensity for the plot.</p></li>
<li><p><strong>y_max</strong> (<em>float</em><em> or </em><em>int</em>) – Maximum intensity for the plot.</p></li>
<li><p><strong>points</strong> (<em>int</em>) – Number of data points.</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – Frequency limits for the plot.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x, y</strong> – Arrays for frequency (x) and intensity (y) for the simulated lineshape.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.plt.mplplot_lineshape">
<code class="sig-prename descclassname">nmrsim.plt.</code><code class="sig-name descname">mplplot_lineshape</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">y_min=None</em>, <em class="sig-param">y_max=None</em>, <em class="sig-param">limits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/plt.html#mplplot_lineshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.plt.mplplot_lineshape" title="Permalink to this definition">¶</a></dt>
<dd><p>A matplotlib plot that accepts arrays of x and y coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em>) – The list of x coordinates.</p></li>
<li><p><strong>y</strong> (<em>array-like</em>) – The list of y coordinates.</p></li>
<li><p><strong>y_min</strong> (<em>float</em><em> or </em><em>int</em>) – Minimum intensity for the plot. Default is -10% max y.</p></li>
<li><p><strong>y_max</strong> (<em>float</em><em> or </em><em>int</em>) – Maximum intensity for the plot. Default is 110% max y.</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – Frequency limits for the plot.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x, y</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The original x, y arguments.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.plt.mplplot_stick">
<code class="sig-prename descclassname">nmrsim.plt.</code><code class="sig-name descname">mplplot_stick</code><span class="sig-paren">(</span><em class="sig-param">peaklist</em>, <em class="sig-param">y_min=-0.01</em>, <em class="sig-param">y_max=1</em>, <em class="sig-param">limits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/plt.html#mplplot_stick"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.plt.mplplot_stick" title="Permalink to this definition">¶</a></dt>
<dd><p>A  matplotlib plot of a spectrum in “stick” (stem) style.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peaklist</strong> (<em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>..</em><em>]</em>) – A list of (frequency, intensity) tuples.</p></li>
<li><p><strong>y_min</strong> (<em>float</em><em> or </em><em>int</em>) – Minimum intensity for the plot.</p></li>
<li><p><strong>y_max</strong> (<em>float</em><em> or </em><em>int</em>) – Maximum intensity for the plot.</p></li>
<li><p><strong>limits</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – Frequency limits for the plot.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The arrays of x and y coordinates used for the plot.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, numpy.array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nmrsim.qm">
<span id="nmrsim-qm-module"></span><h2>nmrsim.qm module<a class="headerlink" href="#module-nmrsim.qm" title="Permalink to this headline">¶</a></h2>
<p>qm contains functions for the quantum-mechanical (second-order)
calculation of NMR spectra.</p>
<p>The qm module provides the following attributes:</p>
<ul class="simple">
<li><dl class="simple">
<dt>CACHE: bool (default True)</dt><dd><p>Whether saving to disk of partial solutions is allowed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>SPARSE: bool (default True)</dt><dd><p>Whether the sparse library can be used.</p>
</dd>
</dl>
</li>
</ul>
<p>The qm module provides the following functions:</p>
<ul class="simple">
<li><p>qm_spinsystem: The high-level function for computing a second-order
simulation from frequency and J-coupling data.</p></li>
<li><p>hamiltonian_dense: Calculate a spin Hamiltonian using dense arrays
(slower).</p></li>
<li><p>hamiltonian_sparse: Calculate a spin Hamiltonian using cached sparse arrays
(faster).</p></li>
<li><p>solve_hamiltonian: Calculate a peaklist from a spin Hamiltonian.</p></li>
<li><p>secondorder_dense: Calculate a peaklist for a second-order spin system,
using dense arrays (slower).</p></li>
<li><p>secondorder_sparse: Calculate a peaklist for a second-order spin system,
using cached sparse arrays (faster).</p></li>
</ul>
<p class="rubric">Notes</p>
<p>Because numpy.matrix is marked as deprecated, starting with Version 0.2.0 the
qm code was refactored to a) accommodate this deprecation and b) speed up the
calculations. The fastest calculations rely on:</p>
<p>1. the pydata/sparse library. SciPy’s sparse depends on numpy.matrix,
and they currently recommend that pydata/sparse be used for now.</p>
<p>2. Caching partial solutions for spin operators and transition matrices as
.npz files.</p>
<p>If the pydata/sparse package is no longer available, and/or if distributing
the library with .npz files via PyPI is problematic, then a backup is
required. The qm module for now provides two sets of functions for
calculating second-order spectra: one using pydata/sparse and caching,
and the other using neither.</p>
<dl class="function">
<dt id="nmrsim.qm.hamiltonian_dense">
<code class="sig-prename descclassname">nmrsim.qm.</code><code class="sig-name descname">hamiltonian_dense</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">J</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/qm.html#hamiltonian_dense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.qm.hamiltonian_dense" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nmrsim.qm.hamiltonian_sparse">
<code class="sig-prename descclassname">nmrsim.qm.</code><code class="sig-name descname">hamiltonian_sparse</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">J</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/qm.html#hamiltonian_sparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.qm.hamiltonian_sparse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>array-like</em>) – list of frequencies in Hz</p></li>
<li><p><strong>J</strong> (<em>2D array-like</em>) – matrix of coupling constants</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>H</strong> – a sparse spin Hamiltonian</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse.COO</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.qm.qm_spinsystem">
<code class="sig-prename descclassname">nmrsim.qm.</code><code class="sig-name descname">qm_spinsystem</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">cache=True</em>, <em class="sig-param">sparse=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/qm.html#qm_spinsystem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.qm.qm_spinsystem" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> – </p></li>
<li><p><strong>cache</strong> – </p></li>
<li><p><strong>sparse</strong> – </p></li>
<li><p><strong>kwargs</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>cutoff</strong> (<em>float</em>) – The intensity cutoff for reporting signals (default is 0.001).</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.qm.secondorder_dense">
<code class="sig-prename descclassname">nmrsim.qm.</code><code class="sig-name descname">secondorder_dense</code><span class="sig-paren">(</span><em class="sig-param">freqs</em>, <em class="sig-param">couplings</em>, <em class="sig-param">normalize=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/qm.html#secondorder_dense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.qm.secondorder_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates second-order spectral data (freqency and intensity of signals)
for <em>n</em> spin-half nuclei.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freqs</strong> (<em>[</em><em>float...</em><em>]</em>) – a list of <em>n</em> nuclei frequencies in Hz</p></li>
<li><p><strong>couplings</strong> (<em>array-like</em>) – an <em>n, n</em> array of couplings in Hz. The order
of nuclei in the list corresponds to the column and row order in the
matrix, e.g. couplings[0][1] and [1]0] are the J coupling between
the nuclei of freqs[0] and freqs[1].</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – True if the intensities should be normalized so that total intensity
equals the total number of nuclei.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>peaklist</strong> – numpy 2D array of [frequency, intensity] pairs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[[float, float]..]</p>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>cutoff</strong> (<em>float</em>) – The intensity cutoff for reporting signals (default is 0.001).</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.qm.secondorder_sparse">
<code class="sig-prename descclassname">nmrsim.qm.</code><code class="sig-name descname">secondorder_sparse</code><span class="sig-paren">(</span><em class="sig-param">freqs</em>, <em class="sig-param">couplings</em>, <em class="sig-param">normalize=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/qm.html#secondorder_sparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.qm.secondorder_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates second-order spectral data (frequency and intensity of signals)
for <em>n</em> spin-half nuclei.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freqs</strong> (<em>[</em><em>float...</em><em>]</em>) – a list of <em>n</em> nuclei frequencies in Hz</p></li>
<li><p><strong>couplings</strong> (<em>array-like</em>) – an <em>n, n</em> array of couplings in Hz. The order
of nuclei in the list corresponds to the column and row order in the
matrix, e.g. couplings[0][1] and [1]0] are the J coupling between
the nuclei of freqs[0] and freqs[1].</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – True if the intensities should be normalized so that total intensity
equals the total number of nuclei.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>peaklist</strong> – of [frequency, intensity] pairs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[[float, float]..] numpy 2D array</p>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>cutoff</strong> (<em>float</em>) – The intensity cutoff for reporting signals (default is 0.001).</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmrsim.qm.solve_hamiltonian">
<code class="sig-prename descclassname">nmrsim.qm.</code><code class="sig-name descname">solve_hamiltonian</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">nspins</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/qm.html#solve_hamiltonian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.qm.solve_hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates frequencies and intensities of signals from a spin Hamiltonian
and number of spins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>numpy.ndarray</em><em> (</em><em>2D</em><em>)</em>) – The spin Hamiltonian</p></li>
<li><p><strong>nspins</strong> (<em>int</em>) – The number of spins in the system</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[[float, float]..] numpy 2D array of frequency, intensity pairs.</p>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>cutoff</strong> (<em>float</em>) – The intensity cutoff for reporting signals (default is 0.001).</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nmrsim">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nmrsim" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nmrsim">
<h3>nmrsim<a class="headerlink" href="#nmrsim" title="Permalink to this headline">¶</a></h3>
<p>The nmrsim package provides tools for simulating nuclear magnetic resonance
(NMR) spectra.</p>
<p>The API is still in flux. Currently, it includes the following modules:</p>
<ul class="simple">
<li><p>dnmr: for modeling Dynamic NMR systems</p></li>
<li><p>firstorder: for modeling first-order spectra</p></li>
<li><p>math: core math routines for handling NMR data</p></li>
<li><p>partial: uses non-quantum-mechanical solutions for common second-order NMR
patterns</p></li>
<li><p>plt: convenience plotting routines for NMR results</p></li>
<li><p>qm: quantum-mechanical second-order simulation of spin systems (currently
capped at 11 nuclei)</p></li>
</ul>
<p>Currently, only spin-1/2 nuclei are accommodated.</p>
<p>The top-level nmrsim namespace provides the following classes:</p>
<ul class="simple">
<li><p>Multiplet: a representation of a first-order multiplet (e.g. quartet;
doublet of triplets).</p></li>
<li><p>SpinSystem: a representation of a set of coupled nuclei (modeled as either
first-order or second-order).</p></li>
<li><p>Spectrum: a collection of components such as Multiplets or SpinSystems that
contribute to a total NMR spectrum simulation.</p></li>
</ul>
<div class="section" id="definitions-of-terms-used">
<h4>Definitions of Terms Used<a class="headerlink" href="#definitions-of-terms-used" title="Permalink to this headline">¶</a></h4>
<p>In naming classes, functions, methods, data types etc. certain phrases, taken from NMR nomenclature, have the following
interpretations:</p>
<ul class="simple">
<li><p><strong>multiplet</strong> (e.g. the <cite>nmrsim.Multiplet</cite> class): a first-order simulation
for one signal (i.e. one or more chemical shift-equivalent nuclei).
Examples: doublet, triplet, doublet of triplets, but <strong>not</strong> an AB quartet
(which is a second-order pattern for two nuclei).</p></li>
<li><p><strong>spin system</strong> (e.g. the <cite>SpinSystem</cite> class): a simulation of a set of
coupled nuclei.</p></li>
<li><p><strong>spectrum</strong> (e.g. the <cite>Spectrum</cite> class): a complete collection of first-
and/or second-order components for simulating a total NMR spectrum.
‘Spectrum’ can also refer in general to the simulation results for the
system, e.g a peaklist or lineshape (see below).</p></li>
<li><p><strong>peak</strong>: a pair of frequency (Hz), intensity values corresponding to a
resonance in an NMR spectrum. For example, a 1H triplet centered at 100 Hz
with J = 10 Hz would have the following  peaks:
(110, 0.25), (100, 0.5), (90, 0.25).</p></li>
<li><p><strong>peaklist</strong>: a list of peaks
(e.g. [(110, 0.25), (100, 0.5), (90, 0.25)] for the above triplet).</p></li>
<li><p><strong>lineshape</strong>: a pair of [x coordinates…], [y coordinates] arrays for
plotting the lineshape of a spectrum.</p></li>
</ul>
<p>The following idioms are used for arguments:
* <strong>v</strong> for a frequency or list of frequencies (similar to the Greek lowercase
“nu” character).
* <strong>I</strong> for a signal intensity  (despite being a PEP8 naming violation)
* <strong>J</strong> for coupling constant data (exact format depends on the
implementation).</p>
<dl class="class">
<dt id="nmrsim.Multiplet">
<em class="property">class </em><code class="sig-prename descclassname">nmrsim.</code><code class="sig-name descname">Multiplet</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">I</em>, <em class="sig-param">J</em>, <em class="sig-param">w=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#Multiplet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.Multiplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A representation of a first-order multiplet.</p>
<dl class="attribute">
<dt id="nmrsim.Multiplet.v">
<code class="sig-name descname">v</code><a class="headerlink" href="#nmrsim.Multiplet.v" title="Permalink to this definition">¶</a></dt>
<dd><p>The frequency of the center of the multiplet.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float or int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmrsim.Multiplet.I">
<code class="sig-name descname">I</code><a class="headerlink" href="#nmrsim.Multiplet.I" title="Permalink to this definition">¶</a></dt>
<dd><p>The total intensity (“integration”) of the multiplet.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float or int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmrsim.Multiplet.J">
<code class="sig-name descname">J</code><a class="headerlink" href="#nmrsim.Multiplet.J" title="Permalink to this definition">¶</a></dt>
<dd><p>For example, a td, <em>J</em> = 7.0, 2.5 Hz would have:
J = [(7.0, 2), (2.5, 1)].</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>2D array-like, e.g. [(int or float, int)..] for [(J, # of nuclei)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmrsim.Multiplet.w">
<code class="sig-name descname">w</code><a class="headerlink" href="#nmrsim.Multiplet.w" title="Permalink to this definition">¶</a></dt>
<dd><p>the peak width at half-height. Currently only used when Multiplet is a
component of a nmrsim.Spectrum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float or int (optional)</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">I</code></dt>
<dd><p>A descriptor used to validate that a class attribute is a real number.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">J</code></dt>
<dd><p>A descriptor used to validate that a value resembles an array of number
pairs (for each J/# of nuclei entry.</p>
</dd></dl>

<dl class="method">
<dt id="nmrsim.Multiplet.peaklist">
<code class="sig-name descname">peaklist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#Multiplet.peaklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.Multiplet.peaklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of (frequency, intensity) signals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Array of (frequency, intensity) signals.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">v</code></dt>
<dd><p>A descriptor used to validate that a class attribute is a real number.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmrsim.SpinSystem">
<em class="property">class </em><code class="sig-prename descclassname">nmrsim.</code><code class="sig-name descname">SpinSystem</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">J</em>, <em class="sig-param">w=0.5</em>, <em class="sig-param">second_order=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#SpinSystem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.SpinSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Stub implementation of SpinSystem.
Flesh out API (e.g. getters/setters; dunder methods) later.</p>
<dl class="method">
<dt id="nmrsim.SpinSystem.J">
<em class="property">property </em><code class="sig-name descname">J</code><a class="headerlink" href="#nmrsim.SpinSystem.J" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2D array of coupling constants.</p>
<p>J[m][n] corresponds to the coupling between the nuclei of frequencies
v[m] and v[n].</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The array of coupling constants.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmrsim.SpinSystem.peaklist">
<code class="sig-name descname">peaklist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#SpinSystem.peaklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.SpinSystem.peaklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of (frequency, intensity) signals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Array of (frequency, intensity) signals.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmrsim.SpinSystem.second_order">
<em class="property">property </em><code class="sig-name descname">second_order</code><a class="headerlink" href="#nmrsim.SpinSystem.second_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the spin system should use second-order simulation (instead
of a first-order simulation). If False, will perform a first-order
calculation instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Whether the spin system should use a second-order simulation
(instead of a first-order simulation).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmrsim.SpinSystem.v">
<em class="property">property </em><code class="sig-name descname">v</code><a class="headerlink" href="#nmrsim.SpinSystem.v" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of the frequency of each nucleus (in the absence of
coupling).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float or int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmrsim.Spectrum">
<em class="property">class </em><code class="sig-prename descclassname">nmrsim.</code><code class="sig-name descname">Spectrum</code><span class="sig-paren">(</span><em class="sig-param">components</em>, <em class="sig-param">vmin=None</em>, <em class="sig-param">vmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#Spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.Spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A collection of spectral features (SpinSystem; Multiplet).</p>
<p>Flesh out API (e.g. getter/setters; dunder methods) later.</p>
<dl class="method">
<dt id="nmrsim.Spectrum.default_limits">
<code class="sig-name descname">default_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#Spectrum.default_limits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.Spectrum.default_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset vmin and vmax to defaults.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Spectrum.vmin, Spectrum.vmax</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float or int, float or int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmrsim.Spectrum.lineshape">
<code class="sig-name descname">lineshape</code><span class="sig-paren">(</span><em class="sig-param">points=800</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#Spectrum.lineshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.Spectrum.lineshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the x and y arrays for the spectrum’s lineshape.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple of x array, y array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[float…], [float…]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmrsim.Spectrum.peaklist">
<code class="sig-name descname">peaklist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmrsim/_classes.html#Spectrum.peaklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmrsim.Spectrum.peaklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the peaklist for the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Array of (frequency, intensity) signals.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[(float, float)..]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Geoffrey M. Sametz

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>