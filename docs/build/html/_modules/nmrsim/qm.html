

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nmrsim.qm &mdash; nmrsim 0.2.0-alpha documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> nmrsim
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction to nmrsim v0.2.0 (alpha)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing to <strong>nmrsim</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgements.html">Acknowledgements</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">nmrsim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>nmrsim.qm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nmrsim.qm</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;qm contains functions for the quantum-mechanical (second-order)</span>
<span class="sd">calculation of NMR spectra.</span>

<span class="sd">The qm module provides the following attributes:</span>

<span class="sd">* CACHE: bool (default True)</span>
<span class="sd">    Whether saving to disk of partial solutions is allowed.</span>
<span class="sd">* SPARSE: bool (default True)</span>
<span class="sd">    Whether the sparse library can be used.</span>

<span class="sd">The qm module provides the following functions:</span>

<span class="sd">* qm_spinsystem: The high-level function for computing a second-order</span>
<span class="sd">  simulation from frequency and J-coupling data.</span>
<span class="sd">* hamiltonian_dense: Calculate a spin Hamiltonian using dense arrays</span>
<span class="sd">  (slower).</span>
<span class="sd">* hamiltonian_sparse: Calculate a spin Hamiltonian using cached sparse arrays</span>
<span class="sd">  (faster).</span>
<span class="sd">* solve_hamiltonian: Calculate a peaklist from a spin Hamiltonian.</span>
<span class="sd">* secondorder_dense: Calculate a peaklist for a second-order spin system,</span>
<span class="sd">  using dense arrays (slower).</span>
<span class="sd">* secondorder_sparse: Calculate a peaklist for a second-order spin system,</span>
<span class="sd">  using cached sparse arrays (faster).</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">Because numpy.matrix is marked as deprecated, starting with Version 0.2.0 the</span>
<span class="sd">qm code was refactored to a) accommodate this deprecation and b) speed up the</span>
<span class="sd">calculations. The fastest calculations rely on:</span>

<span class="sd">1. the pydata/sparse library. SciPy&#39;s sparse depends on numpy.matrix,</span>
<span class="sd">and they currently recommend that pydata/sparse be used for now.</span>

<span class="sd">2. Caching partial solutions for spin operators and transition matrices as</span>
<span class="sd">.npz files.</span>

<span class="sd">If the pydata/sparse package is no longer available, and/or if distributing</span>
<span class="sd">the library with .npz files via PyPI is problematic, then a backup is</span>
<span class="sd">required. The qm module for now provides two sets of functions for</span>
<span class="sd">calculating second-order spectra: one using pydata/sparse and caching,</span>
<span class="sd">and the other using neither.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sparse</span>
<span class="kn">from</span> <span class="nn">nmrsim.math</span> <span class="k">import</span> <span class="n">normalize_peaklist</span>

<span class="n">CACHE</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># saving of partial solutions is allowed</span>
<span class="n">SPARSE</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># the sparse library is available</span>


<span class="k">def</span> <span class="nf">_so_dense</span><span class="p">(</span><span class="n">nspins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate spin operators required for constructing the spin hamiltonian,</span>
<span class="sd">    using dense (numpy) arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nspins: int</span>
<span class="sd">        The number of spins in the spin system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (Lz, Lproduct): a tuple of:</span>
<span class="sd">        Lz: 3d array of shape (n, 2^n, 2^n) representing [Lz1, Lz2, ...Lzn]</span>
<span class="sd">        Lproduct: 4d array of shape (n, n, 2^n, 2^n), representing an n x n</span>
<span class="sd">        array (cartesian product) for all combinations of</span>
<span class="sd">        Lxa*Lxb + Lya*Lyb + Lza*Lzb, where 1 &lt;= a, b &lt;= n.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sigma_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">sigma_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">sigma_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]])</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">nspins</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">nspins</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">nspins</span><span class="p">),</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>  <span class="c1"># TODO: consider other dtype?</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspins</span><span class="p">):</span>
        <span class="n">Lx_current</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Ly_current</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Lz_current</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">Lx_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Lx_current</span><span class="p">,</span> <span class="n">sigma_x</span><span class="p">)</span>
                <span class="n">Ly_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Ly_current</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">)</span>
                <span class="n">Lz_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Lz_current</span><span class="p">,</span> <span class="n">sigma_z</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Lx_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Lx_current</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                <span class="n">Ly_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Ly_current</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                <span class="n">Lz_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Lz_current</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lx_current</span>
        <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ly_current</span>
        <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lz_current</span>

    <span class="c1"># ref:</span>
    <span class="c1"># https://stackoverflow.com/questions/47752324/matrix-multiplication-on-4d-numpy-arrays</span>
    <span class="n">L_T</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">Lproduct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">L_T</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Lproduct</span>


<span class="k">def</span> <span class="nf">_so_sparse</span><span class="p">(</span><span class="n">nspins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Either load a presaved set of spin operators as numpy arrays, or</span>
<span class="sd">    calculate them and save them if a presaved set wasn&#39;t found.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nspins: int</span>
<span class="sd">        the number of spins in the spin system</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (Lz, Lproduct): a tuple of:</span>
<span class="sd">        Lz: 3d sparse.COO array of shape (n, 2^n, 2^n) representing</span>
<span class="sd">        [Lz1, Lz2, ...Lzn]</span>
<span class="sd">        Lproduct: 4d sparse.COO array of shape (n, n, 2^n, 2^n), representing</span>
<span class="sd">        an n x n array (cartesian product) for all combinations of</span>
<span class="sd">        Lxa*Lxb + Lya*Lyb + Lza*Lzb, where 1 &lt;= a, b &lt;= n.</span>

<span class="sd">    Side Effect</span>
<span class="sd">    -----------</span>
<span class="sd">    Saves the results as .npz files to the bin directory if they were not</span>
<span class="sd">    found there.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: once nmrsim demonstrates installing via the PyPI *test* server,</span>
    <span class="c1"># need to determine how the saved solutions will be handled. For example,</span>
    <span class="c1"># part of the final build may be generating these files then testing.</span>
    <span class="c1"># Also, need to consider different users with different system capabilities</span>
    <span class="c1"># (e.g. at extreme, Raspberry Pi). Some way to let user select, or select</span>
    <span class="c1"># for user?</span>
    <span class="n">filename_Lz</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;Lz</span><span class="si">{nspins}</span><span class="s1">.npz&#39;</span>
    <span class="n">filename_Lproduct</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;Lproduct</span><span class="si">{nspins}</span><span class="s1">.npz&#39;</span>
    <span class="n">bin_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;bin&#39;</span><span class="p">)</span>
    <span class="n">path_Lz</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bin_dir</span><span class="p">,</span> <span class="n">filename_Lz</span><span class="p">)</span>
    <span class="n">path_Lproduct</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bin_dir</span><span class="p">,</span> <span class="n">filename_Lproduct</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">Lz</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">path_Lz</span><span class="p">)</span>
        <span class="n">Lproduct</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">path_Lproduct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Lz</span><span class="p">,</span> <span class="n">Lproduct</span>
    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no SO file &#39;</span><span class="p">,</span> <span class="n">filename_Lz</span><span class="p">,</span> <span class="s1">&#39; found in: &#39;</span><span class="p">,</span> <span class="n">bin_dir</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;creating </span><span class="si">{filename_Lz}</span><span class="s1"> and </span><span class="si">{filename_Lproduct}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">Lz</span><span class="p">,</span> <span class="n">Lproduct</span> <span class="o">=</span> <span class="n">_so_dense</span><span class="p">(</span><span class="n">nspins</span><span class="p">)</span>
    <span class="n">Lz_sparse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">COO</span><span class="p">(</span><span class="n">Lz</span><span class="p">)</span>
    <span class="n">Lproduct_sparse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">COO</span><span class="p">(</span><span class="n">Lproduct</span><span class="p">)</span>
    <span class="n">sparse</span><span class="o">.</span><span class="n">save_npz</span><span class="p">(</span><span class="n">path_Lz</span><span class="p">,</span> <span class="n">Lz_sparse</span><span class="p">)</span>
    <span class="n">sparse</span><span class="o">.</span><span class="n">save_npz</span><span class="p">(</span><span class="n">path_Lproduct</span><span class="p">,</span> <span class="n">Lproduct_sparse</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Lz_sparse</span><span class="p">,</span> <span class="n">Lproduct_sparse</span>


<div class="viewcode-block" id="hamiltonian_dense"><a class="viewcode-back" href="../../nmrsim.html#nmrsim.qm.hamiltonian_dense">[docs]</a><span class="k">def</span> <span class="nf">hamiltonian_dense</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
    <span class="n">nspins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">Lz</span><span class="p">,</span> <span class="n">Lproduct</span> <span class="o">=</span> <span class="n">_so_dense</span><span class="p">(</span><span class="n">nspins</span><span class="p">)</span>  <span class="c1"># noqa</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Lz</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">scalars</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">J</span>
    <span class="n">H</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">Lproduct</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="hamiltonian_sparse"><a class="viewcode-back" href="../../nmrsim.html#nmrsim.qm.hamiltonian_sparse">[docs]</a><span class="k">def</span> <span class="nf">hamiltonian_sparse</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v: array-like</span>
<span class="sd">            list of frequencies in Hz</span>
<span class="sd">        J: 2D array-like</span>
<span class="sd">            matrix of coupling constants</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H: sparse.COO</span>
<span class="sd">            a sparse spin Hamiltonian</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">nspins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">Lz</span><span class="p">,</span> <span class="n">Lproduct</span> <span class="o">=</span> <span class="n">_so_sparse</span><span class="p">(</span><span class="n">nspins</span><span class="p">)</span>  <span class="c1"># noqa</span>
    <span class="c1"># On large spin systems, converting v and J to sparse improved speed of</span>
    <span class="c1"># sparse.tensordot calls with them.</span>
    <span class="c1"># First make sure v and J are a numpy array (required by sparse.COO)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">COO</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">Lz</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">scalars</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sparse</span><span class="o">.</span><span class="n">COO</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">+=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">Lproduct</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>


<span class="k">def</span> <span class="nf">_transition_matrix_dense</span><span class="p">(</span><span class="n">nspins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a matrix of allowed transitions, as a dense array.</span>

<span class="sd">    The integers 0-`n`, in their binary form, code for a spin state</span>
<span class="sd">    (alpha/beta). The (i,j) cells in the matrix indicate whether a transition</span>
<span class="sd">    from spin state i to spin state j is allowed or forbidden.</span>
<span class="sd">    See the ``is_allowed`` function for more information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    nspins : number of spins in the system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        a transition matrix that can be used to compute the intensity of</span>
<span class="sd">    allowed transitions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The integers 0-`n`, in their binary form, code for a pure spin state</span>
<span class="sd">    (alpha/beta). For example, for a three-spin system:</span>
<span class="sd">    0 = 000 = alpha-alpha-alpha,</span>
<span class="sd">    1 = 001 = alpha-alpha-beta,</span>
<span class="sd">    ⋮</span>
<span class="sd">    7 = 111 = beta-beta-beta.</span>
<span class="sd">    A transition between two of these states is allowed if only one spin flips.</span>
<span class="sd">    This is equal to a single bit change in the binary representation of the</span>
<span class="sd">    index.</span>

<span class="sd">    The (i,j) cells in the transition matrix indicate whether a transition</span>
<span class="sd">    from spin state i to spin state j is allowed or forbidden (1 = allowed,</span>
<span class="sd">    0 = forbidden).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># function was optimized by only calculating upper triangle and then adding</span>
    <span class="c1"># the lower.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">nspins</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">bin</span><span class="p">(</span><span class="n">i</span> <span class="o">^</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">+=</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">T</span>


<div class="viewcode-block" id="secondorder_dense"><a class="viewcode-back" href="../../nmrsim.html#nmrsim.qm.secondorder_dense">[docs]</a><span class="k">def</span> <span class="nf">secondorder_dense</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">couplings</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates second-order spectral data (freqency and intensity of signals)</span>
<span class="sd">    for *n* spin-half nuclei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    freqs : [float...]</span>
<span class="sd">        a list of *n* nuclei frequencies in Hz</span>
<span class="sd">    couplings : array-like</span>
<span class="sd">        an *n, n* array of couplings in Hz. The order</span>
<span class="sd">        of nuclei in the list corresponds to the column and row order in the</span>
<span class="sd">        matrix, e.g. couplings[0][1] and [1]0] are the J coupling between</span>
<span class="sd">        the nuclei of freqs[0] and freqs[1].</span>
<span class="sd">    normalize: bool</span>
<span class="sd">        True if the intensities should be normalized so that total intensity</span>
<span class="sd">        equals the total number of nuclei.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    peaklist : [[float, float]...]</span>
<span class="sd">        numpy 2D array of [frequency, intensity] pairs.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        The intensity cutoff for reporting signals (default is 0.001).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nspins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">hamiltonian_dense</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">couplings</span><span class="p">)</span>
    <span class="n">E</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">real</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">_transition_matrix_dense</span><span class="p">(</span><span class="n">nspins</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)))</span>
    <span class="n">peaklist</span> <span class="o">=</span> <span class="n">_compile_peaklist</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">peaklist</span> <span class="o">=</span> <span class="n">normalize_peaklist</span><span class="p">(</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">nspins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peaklist</span></div>


<span class="k">def</span> <span class="nf">_tm_cache</span><span class="p">(</span><span class="n">nspins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads a saved sparse transition matrix if it exists, or creates and saves</span>
<span class="sd">    one if it is not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nspins : int</span>
<span class="sd">        The number of spins in the spin system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T_sparse : sparse.COO</span>
<span class="sd">        The sparse transition matrix.</span>

<span class="sd">    Side Effects</span>
<span class="sd">    ------------</span>
<span class="sd">    Saves a sparse array to the bin folder if the required array was not</span>
<span class="sd">    found there.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Speed tests indicated that using sparse-array transition matrices</span>
    <span class="c1"># provides a modest speed improvement on larger spin systems.</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;T</span><span class="si">{nspins}</span><span class="s1">.npz&#39;</span>
    <span class="n">bin_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;bin&#39;</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bin_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">T_sparse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">T_sparse</span>
    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;creating </span><span class="si">{filename}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">T_sparse</span> <span class="o">=</span> <span class="n">_transition_matrix_dense</span><span class="p">(</span><span class="n">nspins</span><span class="p">)</span>
        <span class="n">T_sparse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">COO</span><span class="p">(</span><span class="n">T_sparse</span><span class="p">)</span>
        <span class="n">sparse</span><span class="o">.</span><span class="n">save_npz</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">T_sparse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">T_sparse</span>


<span class="k">def</span> <span class="nf">_intensity_and_energy</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">nspins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate intensity matrix and energies (eigenvalues) from Hamiltonian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:  numpy.ndarray</span>
<span class="sd">        Spin Hamiltonian</span>
<span class="sd">    nspins: int</span>
<span class="sd">        number of spins in spin system</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (I, E): (numpy.ndarray, numpy.ndarray) tuple of:</span>
<span class="sd">        I: (relative) intensity 2D array</span>
<span class="sd">        V: 1-D array of relative energies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">E</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">real</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">_tm_cache</span><span class="p">(</span><span class="n">nspins</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">I</span><span class="p">,</span> <span class="n">E</span>


<span class="k">def</span> <span class="nf">_compile_peaklist</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a peaklist from intensity and energy matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I: numpy.ndarray (2D)</span>
<span class="sd">        matrix of relative intensities</span>
<span class="sd">    E: numpy.ndarray (1D)</span>
<span class="sd">        array of energies</span>
<span class="sd">    cutoff : float, optional</span>
<span class="sd">        The intensity cutoff for reporting signals.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray (2D)</span>
<span class="sd">        A [[frequency, intensity]...] peaklist.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">E_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">E_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">E_matrix</span><span class="p">)</span>
    <span class="n">combo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">E_upper</span><span class="p">,</span> <span class="n">I_upper</span><span class="p">])</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">iv</span><span class="p">[</span><span class="n">iv</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">cutoff</span><span class="p">]</span>


<div class="viewcode-block" id="solve_hamiltonian"><a class="viewcode-back" href="../../nmrsim.html#nmrsim.qm.solve_hamiltonian">[docs]</a><span class="k">def</span> <span class="nf">solve_hamiltonian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">nspins</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates frequencies and intensities of signals from a spin Hamiltonian</span>
<span class="sd">    and number of spins.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H: numpy.ndarray (2D)</span>
<span class="sd">        The spin Hamiltonian</span>
<span class="sd">    nspins : int</span>
<span class="sd">        The number of spins in the system</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [[float, float]...] numpy 2D array of frequency, intensity pairs.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        The intensity cutoff for reporting signals (default is 0.001).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">_intensity_and_energy</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">nspins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_compile_peaklist</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="secondorder_sparse"><a class="viewcode-back" href="../../nmrsim.html#nmrsim.qm.secondorder_sparse">[docs]</a><span class="k">def</span> <span class="nf">secondorder_sparse</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">couplings</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates second-order spectral data (freqency and intensity of signals)</span>
<span class="sd">    for *n* spin-half nuclei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    freqs : [float...]</span>
<span class="sd">        a list of *n* nuclei frequencies in Hz</span>
<span class="sd">    couplings : array-like</span>
<span class="sd">        an *n, n* array of couplings in Hz. The order</span>
<span class="sd">        of nuclei in the list corresponds to the column and row order in the</span>
<span class="sd">        matrix, e.g. couplings[0][1] and [1]0] are the J coupling between</span>
<span class="sd">        the nuclei of freqs[0] and freqs[1].</span>
<span class="sd">    normalize: bool</span>
<span class="sd">        True if the intensities should be normalized so that total intensity</span>
<span class="sd">        equals the total number of nuclei.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    peaklist : [[float, float]...] numpy 2D array</span>
<span class="sd">        of [frequency, intensity] pairs.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        The intensity cutoff for reporting signals (default is 0.001).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nspins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">hamiltonian_sparse</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">couplings</span><span class="p">)</span>
    <span class="n">peaklist</span> <span class="o">=</span> <span class="n">solve_hamiltonian</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">nspins</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">peaklist</span> <span class="o">=</span> <span class="n">normalize_peaklist</span><span class="p">(</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">nspins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peaklist</span></div>


<div class="viewcode-block" id="qm_spinsystem"><a class="viewcode-back" href="../../nmrsim.html#nmrsim.qm.qm_spinsystem">[docs]</a><span class="k">def</span> <span class="nf">qm_spinsystem</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">CACHE</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">SPARSE</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    args</span>
<span class="sd">    cache</span>
<span class="sd">    sparse</span>
<span class="sd">    kwargs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        The intensity cutoff for reporting signals (default is 0.001).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># for key, val in kwargs.items():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">cache</span> <span class="ow">and</span> <span class="n">sparse</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">secondorder_dense</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">secondorder_sparse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Geoffrey M. Sametz

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>